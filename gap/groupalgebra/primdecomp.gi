# <bg>: list[basis, gmodule]
# where <basis>: a basis of a subspace of group ring
#       gmodule: gmodule w.r.t. the basis above
# <e>: element of the subspace above
# return: list[
#   list of elements decomoposition of <e> w.r.t. indecomposable decomposition of the gmodule
#   indecomposition of the gmodule above
# ]
InstallGlobalFunction(ElementDecompositionByIndecomposition, function(bg, e)
    local ElementIndecomposition, b, m, decomp, idemps;

    # Let M be a module over a group ring KG
    # <e>: element of M as row vector w.r.t. a basis of M
    # <m>: mtx module of M
    ElementIndecomposition:= function(e, m)
        local B, I, i, j, V, c, idemps, t;

        I := MTX.Indecomposition(m);
        B := [];
        for i in [1..Length(I)] do
            for j in [1..Length(I[i][1])] do
                Add(B, I[i][1][j]);
            od;
        od;
        V:= FullRowSpace(MTX.Field(m), MTX.Dimension(m));
        B:= Basis(V, B);
        c:= Coefficients(B, e);

        idemps:= [];
        t:= 1;
        for i in [1..Length(I)] do
            idemps[i] := Zero(V);
            for  j in [1..Length(I[i][1])] do
                idemps[i] := idemps[i] + c[t]*B[t];
                t := t + 1;
            od;
        od;
        
        return [idemps, I];
    end;

    b:= bg.basis;
    m:= bg.gmodule;
    decomp:= ElementIndecomposition(Coefficients(b, e), m);
    idemps:= List(decomp[1], i-> LinearCombination(b, i));
    return [idemps, decomp[2]];
end );


# <kg>: group ring
# return: rec(idempotents, gmodule, basis, indecomposition)
# where idempotents: <kg>をブロック分解したときの各ブロック冪等元のリスト
#       basis: <kg>の基底
#       gmodule: basisに関する<kg>のregular gmodule
#       indecomposition: gmoduleをindecompositionした結果
InstallGlobalFunction(BlockDecomposition, function(kg)
    local g, bg, decomp;
    g:= UnderlyingMagma(kg);
    bg:= GBimoduleByRegularAction(g, g, kg, kg);
    decomp:= ElementDecompositionByIndecomposition(bg, One(kg));
    return rec(idempotents:= decomp[1], gmodule:= bg.gmodule, basis:= bg.basis, indecomposition:= decomp[2]);
end );


# Let kg be a group ring.
# <h>: subgroup of g
# <kh>: subalgebra of kg generated by elements of <h>
# return: rec(idempotents, gmodule, basis, indecomposition)
# where idempotents: <kh>をブロック分解したときの各ブロック冪等元のリスト
#       basis: <kh>の基底
#       gmodule: basisに関する<kh>のregular gmodule
#       indecomposition: gmoduleをindecompositionした結果
InstallGlobalFunction(BlockDecompositionInSubgroupRing, function(kh, h)
    local kg, bg, decomp;
    kg:= TopParent(kh);
    bg:= GBimoduleByRegularAction(h, h, kh, kg);
    decomp:= ElementDecompositionByIndecomposition(bg, One(kh));
    return rec(idempotents:= decomp[1], gmodule:= bg.gmodule, basis:= bg.basis, indecomposition:= decomp[2]);
end );


# <kg>: group ring
# <e>: idempotent of <kg>
# return: rec(idempotents, gmodule, basis, indecomposition)
# where idempotents: 右イデアル<e>*<kg>を直既約分解したときの各直既約因子に対応する冪等元のリスト
#       basis: <e>*<kg>の基底
#       gmodule: basisに関する<e>*<kg>のkg-gmodule
#       indecomposition: gmoduleをindecompositionした結果
InstallGlobalFunction(PrimitiveDecomposition, function(e, kg)
    local g, bg, decomp;
    g:= UnderlyingMagma(kg);
    bg:= GBimoduleByRegularAction(TrivialSubgroup(g), g, e*kg, kg);
    decomp:= ElementDecompositionByIndecomposition(bg, e);
    return rec(idempotents:= decomp[1], gmodule:= bg.gmodule, basis:= bg.basis, indecomposition:= decomp[2]);
end );


# Let kg be a group ring.
# <e>: idempotent in kh
# <h>: subgroup of g
# <kh>: subalgebra of kg generated by elements of <h>
# return: rec(idempotents, gmodule, basis, indecomposition)
# where idempotents: 右イデアル<e>*<kh>を直既約分解したときの各直既約因子に対応する冪等元のリスト
#       basis: <e>*<kh>の基底
#       gmodule: basisに関する<e>*<kh>の<kh>-gmodule
#       indecomposition: gmoduleをindecompositionした結果
InstallGlobalFunction(PrimitiveDecompositionInSubgroupRing, function(e, kh, h)
    local kg, bg, decomp;
    kg:= TopParent(kh);
    bg:= GBimoduleByRegularAction(TrivialSubgroup(h), h, e*kh, kg);
    decomp:= ElementDecompositionByIndecomposition(bg, e);
    return rec(idempotents:= decomp[1], gmodule:= bg.gmodule, basis:= bg.basis, indecomposition:= decomp[2]);
end );


# <kg>: group ring
# return: rec(idempotents, gmodule, basis, indecomposition)
# where idempotents: <kg>の単位元を<kg>で原始冪等元分解したときの各原始冪等元のリスト
#       basis: <kg>の基底
#       gmodule: basisに関する<kg>のregular gmodule
#       indecomposition: gmoduleをindecompositionした結果
InstallGlobalFunction(PrimitiveDecompositionOfOne, function(kg)
    return PrimitiveDecomposition(One(kg), kg);
end );


# Let kg be a group ring.
# <h>: subgroup of g
# <kh>: subalgebra of kg generated by elements of <h>
# return: rec(idempotents, gmodule, basis, indecomposition)
# where idempotents: <kh>を直既約分解したときの各直既約因子に対応する原始冪等元のリスト
#       basis: <kh>の基底
#       gmodule: basisに関する<kh>のregular gmodule
#       indecomposition: gmoduleをindecompositionした結果
InstallGlobalFunction(PrimitiveDecompositionOfOneInSubgroupRing, function(kh, h)
    return PrimitiveDecompositionInSubgroupRing(One(kh), kh, h);
end );


# <h>: subgroup of g
# <e>: idempotent in (kg)^Q where h <= Q
# return: rec(idempotents, gmodule, basis, indecomposition, classification )
# where idempotents: <e>*<kg>をk[<h>×g]-moduleとしてみて直既約分解したときの各直既約因子に対応する冪等元のリスト
#       basis: <e>*<kg>の基底
#       gmodule: basisに関する<e>*<kg>のk[<h>×g]-gmodule
#       indecomposition: gmoduleをindecompositionした結果
#       classification : indecomposition の index list を，iso で類別したもの
InstallGlobalFunction(PrimitiveDecompositionInFixedElementsSubalgebra, function(e, h, kg)
    local g, bg, decomp, eqRel, classes;
    g:= UnderlyingMagma(kg);
    bg:= GBimoduleByRegularAction(h, g, e*kg, kg);
    decomp:= ElementDecompositionByIndecomposition(bg, e); # decomp[2] is an indecomposition list

    eqRel := function(i,j) # i,j : indices
        return MTX.IsomorphismModules(decomp[2][i][2],decomp[2][j][2]) <> fail;
    end;
    classes := Classification( [1..Size(decomp[2])], eqRel ); # classification of indices by <eqRel>

    return rec(idempotents:= decomp[1], gmodule:= bg.gmodule, basis:= bg.basis, indecomposition:= decomp[2],
        classification := classes
    );
end );


# Arg
#   <pd> : a primitive decomposition record.
#           (For example, pd := PrimitiveDecompositionInFixedElementsSubalgebra(e, h, kg); )
# Return
#   classification indices determined by isomorphic MTX-modules of <pd>.indecomposition
InstallGlobalFunction( IsomorphicClassification , function( pd )
    local 
        IsIso, classes,
        localReps, nonLocalReps,c, cap;
    
    # Classification 
        IsIso := function(i, j)
            local x,y;
            x := pd.indecomposition[i][2];
            y := pd.indecomposition[j][2];
            return MTX.IsomorphismModules( x, y ) <> fail;
        end;

        classes := Classification( [1..Size(pd.indecomposition)], IsIso );
        pd.classes := classes;

    # Representatives
        if IsBound(pd.localIndices) then 
            localReps := [];    #     local representatives
            nonLocalReps := []; # not local representatives
            # isLocalList := [];  
            for c in pd.classes do
                cap := Intersection(c, pd.localIndices);
                if cap <> [] then 
                    Add( localReps, Representative( cap ) );
                    # Add( isLocalList, true );
                else 
                    Add( nonLocalReps, Representative( c ) );
                    # Add( isLocalList, false );            
                fi;
            od;

            pd.localIndicesReps := localReps;
            pd.nonLocalIndicesReps := nonLocalReps;
        fi;
    
    
    return classes;
end);
